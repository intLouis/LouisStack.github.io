{"meta":{"title":"Welcome!","subtitle":"嘿嘿","description":"就职于不知名小公司，无事来此放放屁","author":"Louis","url":"https://intlouis.github.io","root":"/"},"pages":[{"title":"关于我","date":"2022-03-25T17:45:27.000Z","updated":"2022-03-26T08:19:35.894Z","comments":true,"path":"about/index.html","permalink":"https://intlouis.github.io/about/index.html","excerpt":"","text":"https://www.bilibili.com/video/BV1UL4y1u7Sn?spm_id_from=333.851.b_7265636f6d6d656e64.1 有梦想的菜鸟罢了。"},{"title":"分类","date":"2022-03-25T17:40:40.000Z","updated":"2022-03-26T08:01:58.961Z","comments":true,"path":"categories/index.html","permalink":"https://intlouis.github.io/categories/index.html","excerpt":"","text":""},{"title":"友链","date":"2022-03-18T01:49:42.000Z","updated":"2022-03-18T01:50:45.199Z","comments":true,"path":"link/index.html","permalink":"https://intlouis.github.io/link/index.html","excerpt":"","text":""},{"title":"标签😄","date":"2022-03-25T17:39:45.000Z","updated":"2022-03-26T08:02:29.473Z","comments":true,"path":"tags/index.html","permalink":"https://intlouis.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"微服务浅谈（二）——服务调用&OpenFeign","slug":"SpringCloud-OpenFeign","date":"2022-03-14T16:41:15.000Z","updated":"2022-03-25T17:08:11.981Z","comments":true,"path":"2022/03/15/SpringCloud-OpenFeign/","link":"","permalink":"https://intlouis.github.io/2022/03/15/SpringCloud-OpenFeign/","excerpt":"","text":"服务调用的两种常用方式：RPC&amp;HTTPHTTP就不过多介绍了，稍微讲一下RPC的架构。 RPC架构一个完整的RPC架构里面包含了四个核心的组件，分别是Client，Client Stub，Server以及Server Stub，这个Stub可以理解为存根。 客户端(Client)，服务的调用方。 客户端存根(Client Stub)，存放服务端的地址消息，再将客户端的请求参数打包成网络消息，然后通过网络远程发送给服务方。 服务端(Server)，真正的服务提供者。 服务端存根(Server Stub)，接收客户端发送过来的消息，将消息解包，并调用本地的方法。 纵观整个过程，实际上就是客户端发起调用，然后本次调用经过Client Stub封装，发送给Server，然后Server Stub会解析发送过来的内容，并且将数据进行返回。 RPC的目标就是要把2、3、4、7、8、9这些步骤都封装起来。 RPC调用是使用自定义的数据格式进行传输，是基于原生TCP进行通信，速度较快，效率较高。 HTTP则是一种较为通用的调用方式，在跨语言上存在优势，只要提供restful风格的接口，则可以进行请求。 关于RPC与Http的技术选型：如果需要使用RPC调用，则需要服务提供方与消费方都是使用RPC调用，即需要双方使用相同的技术，如都使用Dubbo调用。 而Http则无需关注语言的实现，只需请求数据遵循restful规范即可。 如何选择？ 既然两种方式都可以实现远程调用，我们该如何选择呢？ 速度来看，RPC要比http更快，虽然底层都是TCP，但是http协议的信息往往比较臃肿 难度来看，RPC实现较为复杂，http相对比较简单 灵活性来看，http更胜一筹，因为它不关心实现细节，跨平台、跨语言。 因此，两者都有不同的使用场景： 如果对效率要求更高，并且开发过程使用统一的技术栈，那么用RPC还是不错的。 如果需要更加灵活，跨语言、跨平台，显然http更合适 那么我们该怎么选择呢？ 微服务，更加强调的是独立、自治、灵活。而RPC方式的限制较多，因此微服务框架中，一般都会采用基于Http的Rest风格服务。 RestTemplate存在的问题其实Rest存在的问题，只需要三个字概况，不够优雅（四个字），当调用服务的url拼接较多的参数时，这样的url会变得非常难以维护，这样拼接的url在实际生产中并不少见。 OpenFeign简介OpenFeign是一种可以在微服务之间实现“无感知调用“的一个中间件。 即引入这种中间件以后，各个接口之间的调用就像在单机上部署一样，无需过多的关注调用的地址和端口，这就是所谓的”无感知调用“，或许这样描述并不是非常恰当，但达意即可。 SpringMVC的注解，如@RequestMapping等等。OpenFeign的@FeignClient可以解析SpringMVC的@RequestMapping注解下的接口，并通过动态代理的方式产生实现类，实现类中做负载均衡并调用其他服务。 OpenFeign沿用SpringMVC的注解，大大地降低了学习成本，作为一个组件它是一个好组件😀 OpenFeign的底层还是使用了Ribbon，Ribbon的介绍在博客相关文章有介绍过，所以OpenFeign是一个调用+客户端负载均衡的一个微服务组件。 OpenFeign把RestTemplete，Ribbon，Hystrix糅合在了一起，在使用时就可以更加方便，优雅地完成整个服务的暴露，调用等。避免做一些重复的复制粘贴接口URL，或者重复定义接口等。还是非常值得去学习的。 但Hystrix一般由Sentinel代替了，关于Sentinel的博客文章后续会发布。 OpenFeign的简单使用 1、在启动类上增加@EnableFeignClients注解（注：以下例子来自OpenFeign官方文档） 1234567891011121314@SpringBootApplication@EnableFeignClientspublic class WebApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(WebApplication.class, args); &#125; @FeignClient(&quot;name&quot;) static interface NameService &#123; @RequestMapping(&quot;/&quot;) public String getName(); &#125;&#125; 2、StoreClient就是供消费者调用的接口，每个接口上添加MVC相应注解以及接口请求地址。一般来说会专门创建一个这样的interface以供消费者调用。 1234567891011121314@FeignClient(&quot;stores&quot;)public interface StoreClient &#123; @RequestMapping(method = RequestMethod.GET, value = &quot;/stores&quot;) List&lt;Store&gt; getStores(); @RequestMapping(method = RequestMethod.GET, value = &quot;/stores&quot;) Page&lt;Store&gt; getStores(Pageable pageable); @RequestMapping(method = RequestMethod.POST, value = &quot;/stores/&#123;storeId&#125;&quot;, consumes = &quot;application/json&quot;) Store update(@PathVariable(&quot;storeId&quot;) Long storeId, Store store); @RequestMapping(method = RequestMethod.DELETE, value = &quot;/stores/&#123;storeId:\\\\d+&#125;&quot;) void delete(@PathVariable Long storeId);&#125; 3、在消费者的Controller层，注入StoreClient这个对象，使用这个对象直接进行方法调用即可。 Feign的自定义配置日志级别： NONE：不打印任何日志。 BASIC：只记录请求方法、URL、响应状态码和执行时间 HEADERS：记录基本信息，请求和响应标题 FULL： 记录请求和响应标题、正文和行数据 还有其他的Feign自定义配置，在此就不一一赘述。","categories":[],"tags":[]},{"title":"微服务浅谈（一）——Nacos","slug":"SpringCloud_Nacos","date":"2022-03-13T11:31:08.440Z","updated":"2022-03-25T18:12:30.809Z","comments":true,"path":"2022/03/13/SpringCloud_Nacos/","link":"","permalink":"https://intlouis.github.io/2022/03/13/SpringCloud_Nacos/","excerpt":"","text":"服务注册中心注册中心基本原理 在使用注册中心时，一共有三种角色：服务提供者（Service Provider）、服务消费者（Service Consumer）、注册中心（Registry）。 服务发现原理：服务发现机制就是通过一个中间件去记录服务提供者的ip地址，服务名以及心跳等数据（比如用mysql去存储这些信息），然后服务消费者会去这个中间平台去查询相关信息，然后再去访问对应的地址，这就是服务注册和服务发现。 Nacos 提供对服务的实时的健康检查，阻止向不健康的主机或服务实例发送请求。Nacos 支持传输层 (PING 或 TCP)和应用层 (如 HTTP、MySQL、用户自定义）的健康检查。 对于复杂的云环境和网络拓扑环境中（如 VPC、边缘网络等）服务的健康检查，Nacos 提供了 agent 上报模式和服务端主动检测2种健康检查模式。Nacos 还提供了统一的健康检查仪表盘，帮助您根据健康状态管理服务的可用性及流量。 服务提供者：向注册中心注册为一个服务实例，并且向外部暴露调用接口。 服务消费者：向注册中心订阅需要调用的服务，并缓存服务的实例列表再内存中。后续，Consumer 向对应服务的 Provider 发起调用时，从内存中的该服务的实例列表选择一个，进行远程调用。 注册中心：当注册的实例超过一定时间未心跳（nacos默认30s心跳一次，若下一次未收到，将不再路由请求至该实例），则注册中心判断这个服务已下线，将从服务实例列表移除。 不同的注册中心可能在实现原理上会略有差异。例如说，Eureka 注册中心，并不提供通知功能，而是 Eureka Client 自己定期轮询，实现本地缓存的更新。 当然，一个服务消费者，也可以是一个服务提供者。 nacos 作为注册中心时，Namespace + Group + Service 作为配置中心时，Namespace + Group + DataId 元数据： Nacos数据（如配置和服务）描述信息，如服务版本、权重、容灾策略、负载均衡策略、鉴权配置、各种自定义标签（label），从作用范围来看，分为服务级别的元信息、集群的元信息及实例的元信息。 Nacos1.x与Nacos2.xNacos1.x对比存在的问题 1、心跳续约是30s（默认），当服务较多时，就会有较高的TPS数。 2、心跳感知问题，心跳感知为15s无应答，即15秒未感知到应用心跳时，才能删除实例，在并发较高的情况下，降低服务的高可用。如：当服务宕机时，需要快速剔除服务实例，但需要等待15s，这样的时效性并不理想。 3、有HTTP和UDP两种数据推送的方式，与客户端需要进行全量对账（保持服务发现），会进行大量查询，导致QPS较高，这种可以理解成牺牲大量的查询来保持服务的发现，但实际生产中，所有的服务都是较为稳定的，大量的查询实际是为了那仅有的几个服务变动而设计，这样的性价比并不高。 Nacos2.x优化 1、使用长连接进行心跳续约，大大降低重复请求。同时长连接在断开时是可以快速感知到的，不需要等待15s。 2、连接反复创建存在开销，使用长连接减少了这样的开销，同时减少了TIME_WAIT的问题。 2.0架构带来的问题 相对于Tomcat HTTP短连接模型，长连接模型需要自己管理连接状态，增加了复杂性 长连接gRPC基于HTTP2.0 Stream，相对于HTTP的open API可观测性和易用性降低了 两者性能对比 具体性能分析可参照这篇博文：重磅官宣：Nacos2.0 发布，性能提升 10 倍 负载均衡服务器端负载均衡： 由中间件Ng进行路由 客户端负载均衡： 根据负载均衡规则，自行请求。 Ribbon：提供丰富的负载均衡算法。 手写一个客户端侧负载均衡器 手写负载均衡器部分代码如图： 这段代码的意思就是在实例列表中随机进行请求。这段代码只是粗略展示负载均衡的其中一个算法。 手写负载均衡器主要原理就是获取到此服务的所有url，然后以轮询、随机等方式进行调用指定的url Ribbon与Nginx的区别既然提到了负载均衡，怎么能少得了Nginx呢，Ribbon和Nginx之间的不同在于，Nginx是集中式的对接收的请求进行负载均衡，而Ribbon是在消费者端进行负载均衡，形象一点就是如下图。 NginxNginx的工作模型如下图： RibbonRibbon的工作模型如下图 Ribbon的负载均衡与Ng的负载均衡之不同就是，Ng是被动负载均衡，Ribbon是主动负载均衡。 Ribbon会在收到Http请求后，去拉取注册中心中的服务实例List，获取到List以后，会使用负载均衡策略，在List中挑选一个服务实例进行请求。 Ribbon默认是懒加载，懒加载会使项目启动速度加快，但是同时在第一次请求时，会去拉取注册中心的服务实例，以及初始化负载均衡容器，导致请求响应速度相对较慢。同时可选定服务进行配置饥饿加载。 同时Ribbon有多种负载均衡的策略模式可供选择，默认的就是同区域轮训模式：ZoneAwareLoadBalancer 是一个根据区域（Zone） 来进行负载均衡器，因为如果不同机房跨区域部署服务列表，跨区域的方式访问会产生更高的延迟，ZoneAwareLoadBalancer 就是为了解决此类问题，不过默认都是同一区域 Ribbon负载均衡策略： 策略类 命名 描述 RandomRule 随机策略 随机选择server RoundRobinRule 轮询策略 轮询选择， 轮询index，选择index对应位置的Server； RetryRule 重试策略 对选定的负载均衡策略机上重试机制，在一个配置时间段内当选择Server不成功，则一直尝试使用subRule的方式选择一个可用的server； BestAvailableRule 最低并发策略 逐个考察server，如果server断路器打开，则忽略，再选择其中并发链接最低的server AvailabilityFilteringRule 可用过滤策略 过滤掉一直失败并被标记为circuit tripped的server，过滤掉那些高并发链接的server（active connections超过配置的阈值）或者使用一个AvailabilityPredicate来包含过滤server的逻辑，其实就就是检查status里记录的各个Server的运行状态； ResponseTimeWeightedRule 响应时间加权重策略 根据server的响应时间分配权重，响应时间越长，权重越低，被选择到的概率也就越低。响应时间越短，权重越高，被选中的概率越高，这个策略很贴切，综合了各种因素，比如：网络，磁盘，io等，都直接影响响应时间 ZoneAvoidanceRule 区域权重策略 综合判断server所在区域的性能，和server的可用性，轮询选择server并且判断一个AWS Zone的运行性能是否可用，剔除不可用的Zone中的所有server","categories":[{"name":"微服务","slug":"微服务","permalink":"https://intlouis.github.io/categories/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"}],"tags":[{"name":"Nacos","slug":"Nacos","permalink":"https://intlouis.github.io/tags/Nacos/"},{"name":"微服务","slug":"微服务","permalink":"https://intlouis.github.io/tags/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"},{"name":"SpringCloud","slug":"SpringCloud","permalink":"https://intlouis.github.io/tags/SpringCloud/"}]}],"categories":[{"name":"微服务","slug":"微服务","permalink":"https://intlouis.github.io/categories/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"}],"tags":[{"name":"Nacos","slug":"Nacos","permalink":"https://intlouis.github.io/tags/Nacos/"},{"name":"微服务","slug":"微服务","permalink":"https://intlouis.github.io/tags/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"},{"name":"SpringCloud","slug":"SpringCloud","permalink":"https://intlouis.github.io/tags/SpringCloud/"}]}