<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>消息中间件（1）——之Kafka | Welcome!</title><meta name="keywords" content="-消息队列 -Kafka"><meta name="author" content="Louis,378435665@qq.com"><meta name="copyright" content="Louis"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="讲完微服务四大基本组件以后，接下来会发布消息中间件的系列文章，所以第一篇的话选择介绍Kafka。 言归正传  以经典的电商秒杀场景，设想10000件商品在几秒内被秒杀抢购完，我们如何保证在这么短的时间内扛下如此之高的并发，如果机器性能较差，上千甚至上万的QPS直接打在机器上，tomcat线程池一定会被打满，引发生产事故。 此时就需要用到消息中间件，无论有多少请求，统统暂存至MQ，然后服务器慢慢消费">
<meta property="og:type" content="article">
<meta property="og:title" content="消息中间件（1）——之Kafka">
<meta property="og:url" content="https://intlouis.github.io/2022/04/23/MQ-kafka/index.html">
<meta property="og:site_name" content="Welcome!">
<meta property="og:description" content="讲完微服务四大基本组件以后，接下来会发布消息中间件的系列文章，所以第一篇的话选择介绍Kafka。 言归正传  以经典的电商秒杀场景，设想10000件商品在几秒内被秒杀抢购完，我们如何保证在这么短的时间内扛下如此之高的并发，如果机器性能较差，上千甚至上万的QPS直接打在机器上，tomcat线程池一定会被打满，引发生产事故。 此时就需要用到消息中间件，无论有多少请求，统统暂存至MQ，然后服务器慢慢消费">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://intlouis.github.io/imgs/007ZVs3Jgy1h0qz8hqf8cj30go0go75i.jpg">
<meta property="article:published_time" content="2022-04-23T14:09:45.000Z">
<meta property="article:modified_time" content="2022-05-12T14:39:17.819Z">
<meta property="article:author" content="Louis">
<meta property="article:tag" content="-消息队列 -Kafka">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://intlouis.github.io/imgs/007ZVs3Jgy1h0qz8hqf8cj30go0go75i.jpg"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://intlouis.github.io/2022/04/23/MQ-kafka/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery@2/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery@2/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '消息中间件（1）——之Kafka',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2022-05-12 22:39:17'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 5.4.1"></head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">加载中...</div></div></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/img.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data is-center"><div class="data-item"><a href="/archives/"><div class="headline">文章</div><div class="length-num">10</div></a></div><div class="data-item"><a href="/tags/"><div class="headline">标签</div><div class="length-num">15</div></a></div><div class="data-item"><a href="/categories/"><div class="headline">分类</div><div class="length-num">2</div></a></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于我</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('/imgs/007ZVs3Jgy1h0qz8hqf8cj30go0go75i.jpg')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">Welcome!</a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于我</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">消息中间件（1）——之Kafka</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2022-04-23T14:09:45.000Z" title="发表于 2022-04-23 22:09:45">2022-04-23</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2022-05-12T14:39:17.819Z" title="更新于 2022-05-12 22:39:17">2022-05-12</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E5%BE%AE%E6%9C%8D%E5%8A%A1/">微服务</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">6.3k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>19分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="消息中间件（1）——之Kafka"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><p>讲完微服务四大基本组件以后，接下来会发布消息中间件的系列文章，所以第一篇的话选择介绍Kafka。</p>
<p>言归正传</p>
<blockquote>
<p>以经典的电商秒杀场景，设想10000件商品在几秒内被秒杀抢购完，我们如何保证在这么短的时间内扛下如此之高的并发，<strong>如果机器性能较差，上千甚至上万的QPS直接打在机器上，tomcat线程池一定会被打满，引发生产事故。</strong></p>
<p>此时就需要用到消息中间件，无论有多少请求，统统暂存至MQ，然后服务器慢慢消费，既保证了消息不丢失，也大大减轻了机器的压力。</p>
<p>MQ是高并发场景下常用的中间件，这样的场景一定会依赖MQ，同时MQ也常会用于服务之间的数据同步。</p>
</blockquote>
<h1 id="基本术语"><a href="#基本术语" class="headerlink" title="基本术语"></a>基本术语</h1><p><strong>消息：</strong>Kafka 中的数据单元被称为<code>消息</code>，也被称为记录，可以把它看作数据库表中某一行的记录。记录可以是用户发起的http请求。</p>
<p><strong>主题（Topic）：</strong>消息的种类称为 <code>主题</code>,可以说一个主题代表了一类消息。相当于是对消息进行分类。主题就像是数据库中的表。</p>
<p><strong>分区（partition）：</strong>同一个主题中的分区均匀分布在机器集群，这样可以更好实现服务器集群组的负载均衡。</p>
<blockquote>
<p>分区的作用就是让消费者集群中的节点都能消费到同一个topic的消息，假如没有分区，那topicA部署在其中一个节点上，这个节点服务器的压力就会很大，而分区是让消费者集群中都部署topicA，这样消费者就会均匀的把消息发送到每个topicA下。</p>
<p>相当于创建了n个文件夹去存储这些消息。不会把所有的消息都放在一个文件夹里。</p>
</blockquote>
<img src="/imgs/MQ-kafka/16eb068bab005524tplv-t2oaga2asx-zoom-in-crop-mark1304000.awebp" alt="img" style="zoom: 50%;" />



<p><strong>生产者（Producer）：</strong>MQ中非常重要的概念，向主题（topic）发送消息的就是生产者。</p>
<p><strong>消费者（Consumer）：</strong>MQ中非常重要的概念，订阅主题（topic）消息的客户端就是消费者，用于处理生产者产生的消息。</p>
<p><strong>偏移量：</strong><code>偏移量</code>（Consumer Offset）是一种元数据，它是一个不断递增的整数值，用来记录消费者发生<strong>重平衡（Rebalance）</strong>时的位置，以便用来恢复数据。</p>
<p><strong>broker:</strong> 一个独立的 Kafka 服务器就被称为 <code>broker</code>，broker 接收来自生产者的消息，为消息设置偏移量，并提交消息到磁盘保存。</p>
<p><strong>broker 集群：</strong>broker 是<code>集群</code> 的组成部分，broker 集群由一个或多个 broker 组成，每个集群都有一个 broker 同时充当了<code>集群控制器</code>的角色（自动从集群的活跃成员中选举出来）。</p>
<p><strong>重平衡（Rebalance）：</strong>试想，消费组集群中某个实例节点挂掉以后，其他消费者实例自动重新分配topic分区的过程。实现了Kafka的消费端高可用。</p>
<h1 id="Kafka特性"><a href="#Kafka特性" class="headerlink" title="Kafka特性"></a>Kafka特性</h1><p><code>高吞吐、低延迟</code>：kakfa 最大的特点就是收发消息非常快，kafka 每秒可以处理几十万条消息，它的最低延迟只有几毫秒。</p>
<p><code>高伸缩性</code>： 每个主题(topic) 包含多个分区(partition)，主题中的分区可以分布在不同的主机(broker)中。</p>
<p><code>持久性、可靠性</code>： Kafka 能够允许数据的持久化存储，消息被持久化到磁盘，并支持数据备份防止数据丢失，Kafka 底层的数据存储是基于 Zookeeper 存储的，Zookeeper 我们知道它的数据能够持久存储。</p>
<p><code>容错性</code>： 允许集群中的节点失败，某个节点宕机，Kafka 集群能够正常工作</p>
<p><code>高并发</code>： 支持数千个客户端同时读写</p>
<h1 id="Kafka-的消息队列模式"><a href="#Kafka-的消息队列模式" class="headerlink" title="Kafka 的消息队列模式"></a>Kafka 的消息队列模式</h1><blockquote>
<p>一班消息队列模式分为两种：点对点，发布-订阅者模式。</p>
</blockquote>
<p>点对点应该很好理解，就是一个生产者对应一个消费者。</p>
<p>如果是多个生产者对应多个消费者，即生产者集群—消费者集群这样子，就是发布订阅者模式。<strong>发布订阅者模式也是设计模式之一，同时也是MQ的核心设计思想之一。</strong></p>
<img src="/imgs/MQ-kafka/16eb068cc433bb21tplv-t2oaga2asx-zoom-in-crop-mark1304000.awebp" alt="img" style="zoom: 80%;" />



<p>图中所示，一个Kafka集群包含若干个broker、producer、和consumer。</p>
<p>Kafka通过zk管理集群配置，从而选举leader。在consumer发生变化时（例如某个实例挂掉）进行Rebalance。</p>
<h1 id="四个核心API"><a href="#四个核心API" class="headerlink" title="四个核心API"></a>四个核心API</h1><p>Producer API，它允许应用程序向一个或多个 topics 上发送消息记录</p>
<p>Consumer API，允许应用程序订阅一个或多个 topics 并处理为其生成的记录流</p>
<p>Streams API，它允许应用程序作为流处理器，从一个或多个主题中消费输入流并为其生成输出流，有效的将输入流转换为输出流。</p>
<p>Connector API，它允许构建和运行将 Kafka 主题连接到现有应用程序或数据系统的可用生产者和消费者</p>
<h1 id="Kafka-为何如此之快"><a href="#Kafka-为何如此之快" class="headerlink" title="Kafka 为何如此之快"></a>Kafka 为何如此之快</h1><blockquote>
<p>话不多说，Kafka以高性能、高吞吐量、高并发而闻名，下面介绍一下Kafka的零拷贝与批量、顺序写入。</p>
</blockquote>
<h2 id="零拷贝"><a href="#零拷贝" class="headerlink" title="零拷贝"></a>零拷贝</h2><p>广义上的零拷贝，<strong>意思就是减少不必要的拷贝次数</strong>，并不是真正的不需要拷贝。而减少了不必要的拷贝次数，那就是减少了拷贝次数，提高传输效率，同时也省去了CPU切换上下文的时间。</p>
<h2 id="前景提要：DMA（Direct-Memory-Access）"><a href="#前景提要：DMA（Direct-Memory-Access）" class="headerlink" title="前景提要：DMA（Direct Memory Access）"></a>前景提要：DMA（Direct Memory Access）</h2><blockquote>
<p>直接内存访问（Direct Memory Access），是一种硬件设备绕开CPU独立直接访问内存的机制。所以DMA在一定程度上解放了CPU，把之前CPU的杂活让硬件直接自己做了，提高了CPU效率。</p>
<p>目前支持DMA的硬件包括：网卡、声卡、显卡、磁盘控制器等。</p>
<p>是一种允许外围设备（硬件子系统）直接访问系统主内存的机制。也就是说，基于 DMA 访问方式，系统主内存于硬盘或网卡之间的数据传输可以绕开 CPU 的全程调度。目前大多数的硬件设备，包括磁盘控制器、网卡、显卡以及声卡等都支持 DMA 技术。</p>
</blockquote>
<p>只有CPU参与的数据传输时，CPU将参与全局的I/O操作，有不小的上下文切换开销、等待数据读取拷贝时间开销等等。如图：</p>
<img src="/imgs/MQ-kafka/2f4523363ce84fd181ba01b7ea85c0d4tplv-k3u1fbpfcp-zoom-in-crop-mark1304000.webp" alt="img" style="zoom: 80%;" />



<p>引入DMA后，CPU将从这些操作中解放出来，这些操作将有DMA来完成，而CPU可以并行地去做别的事情。</p>
<p><strong>这样在大部分时间里，CPU 计算和 I/O 操作都处于并行操作，使整个计算机系统的效率大大提高。</strong></p>
<img src="/imgs/MQ-kafka/0c5b70b710f3429c914afbfab7883251tplv-k3u1fbpfcp-zoom-in-crop-mark1304000.webp" alt="img"  />







<p>我直接<strong>偷一张图</strong>来说明应用读写磁盘时，数据拷贝的过程：</p>
<p>图中可知，普通的数据交互，会发生<strong>CPU的上下文切换</strong>和<strong>用户态到内核态的转换</strong>。</p>
<p>这样是会对整个数据交互带来一定的开销，一般来说这是正常开销，但在成千上万次数据交互的过程中，这样的开销会占用很大一部分时间。</p>
<img src="/imgs/MQ-kafka/183a6c6e57734e80862250a93603b56atplv-k3u1fbpfcp-zoom-in-crop-mark1304000.awebp" alt="img" style="zoom: 80%;" />

<p><strong>读数据过程：</strong></p>
<ul>
<li>应用程序要读取磁盘数据，调用read()函数从而实现用户态切换内核态，这是第1次状态切换；</li>
<li>DMA控制器将数据从磁盘拷贝到内核缓冲区，这是第1次DMA拷贝；</li>
<li>CPU将数据从内核缓冲区复制到用户缓冲区，这是第1次CPU拷贝；</li>
<li>CPU完成拷贝之后，read()函数返回实现用户态切换用户态，这是第2次状态切换；</li>
</ul>
<p><strong>写数据过程：</strong></p>
<ul>
<li>应用程序要向网卡写数据，调用write()函数实现用户态切换内核态，这是第1次切换；</li>
<li>CPU将用户缓冲区数据拷贝到内核缓冲区，这是第1次CPU拷贝；</li>
<li>DMA控制器将数据从内核缓冲区复制到socket缓冲区，这是第1次DMA拷贝；</li>
<li>完成拷贝之后，write()函数返回实现内核态切换用户态，这是第2次切换；</li>
</ul>
<p><strong>所以有没有一种情况，应用不对数据做处理，那这样还有什么必要进入到应用的缓冲区呢？</strong></p>
<p>此时，零拷贝出现了。</p>
<p>零拷贝的实现手段，有mmap+write、sendfile、sendfile+DMA收集、splice等，在此着重讲解前二者。</p>
<hr>
<p>2022.04.25 马不停蹄学习中……</p>
<h2 id="mmap"><a href="#mmap" class="headerlink" title="mmap"></a>mmap</h2><p>mmap是Linux提供的一种内存映射文件方法。</p>
<p>使用mmap会将内核空间中的<strong>读缓冲区（read buffer）</strong>的地址，与用户空间（user buffer）进行映射，从而实现内核缓冲区与程序内存的共享。</p>
<p>省去了将<strong>数据从内核空间拷贝到用户空间</strong>这个开销，但是仍然需要将数据copy到内核的写缓冲区</p>
<img src="/imgs/MQ-kafka/cf56b7f22d784a54b9abdbed143895f8tplv-k3u1fbpfcp-zoom-in-crop-mark1304000.webp" alt="img" style="zoom:67%;" />

<p>mmap 主要的用处是提高 I/O 性能，特别是针对大文件。对于小文件，内存映射文件反而会导致碎片空间的浪费，因为内存映射总是要对齐页边界，最小单位是 4 KB，一个 5 KB 的文件将会映射占用 8 KB 内存，也就会浪费 3 KB 内存。</p>
<h2 id="sendfile"><a href="#sendfile" class="headerlink" title="sendfile"></a>sendfile</h2><p>Linux内核版本2.1中被引入。主要建立了两个文件之间的传输通道。</p>
<p><strong>通过 sendfile 系统调用，数据可以直接在内核空间内部进行 I/O 传输，从而省去了数据在用户空间和内核空间之间的来回拷贝。</strong></p>
<p>与mmap不同的是，对于用户而言，<strong>senfile是不可见的，但是可以感知到的</strong>。</p>
<p>用户会用senfile而发起数据传输，同时传输结束后会得到结果，但并不知道数据传输的过程，因为senfile不会经历到用户空间。</p>
<img src="/imgs/MQ-kafka/88660345a54f4d8d9fadf442f85c5217tplv-k3u1fbpfcp-zoom-in-crop-mark1304000.webp" alt="img" style="zoom: 67%;" />



<hr>
<p>零拷贝讲了这么多，涉及过多的计算机组成原理和操作系统知识，不明白的同学可以去了解一下这部分的基础。</p>
<h1 id="Kafka消息发送"><a href="#Kafka消息发送" class="headerlink" title="Kafka消息发送"></a>Kafka消息发送</h1><blockquote>
<p>其消息发送有几种模式，简单消息发送、同步消息发送、异步消息发送。</p>
</blockquote>
<h2 id="简单消息发送"><a href="#简单消息发送" class="headerlink" title="简单消息发送"></a>简单消息发送</h2><img src="/imgs/MQ-kafka/16eb068cd8d08784tplv-t2oaga2asx-zoom-in-crop-mark1304000.webp" alt="img" style="zoom: 50%;" />

<p>代码中生产者(producer)的 <code>send()</code> 方法需要把 <code>ProducerRecord</code> 的对象作为参数进行发送，ProducerRecord 有很多构造函数，这个我们下面讨论，</p>
<p>这里调用的是ProducerRecord，这个构造函数，需要传递的是 topic主题，key 和 value。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ProducerRecord&lt;String,String&gt; record =</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">ProducerRecord</span>&lt;String, String&gt;(<span class="string">&quot;CustomerCountry&quot;</span>,<span class="string">&quot;West&quot;</span>,<span class="string">&quot;France&quot;</span>);</span><br><span class="line"></span><br><span class="line">producer.send(record);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">ProducerRecord</span><span class="params">(String topic, K key, V value)</span> &#123;&#125;</span><br></pre></td></tr></table></figure>



<p>从其架构图可知，生产者调用send方法后，会将消息写入分区的缓冲区中，分批次发给 broker。</p>
<h2 id="同步发送消息"><a href="#同步发送消息" class="headerlink" title="同步发送消息"></a>同步发送消息</h2><blockquote>
<p>同步就不用过多赘述了，就是生产者调用send()消息后，会再调用get()方法等待Kafka响应。如果服务器返回错误，get()方法会抛出异常。</p>
</blockquote>
<p>反之，会返回一个<code>RecordMetadata</code> 对象。</p>
<p>生产者（KafkaProducer）在发送的过程中会出现三类错误：</p>
<ol>
<li>重试错误，这类错误可以通过重发消息来解决。</li>
<li>连接的错误，可以通过再次建立连接来解决；</li>
<li>无<code>主</code>错误则可以通过重新为分区选举首领来解决。</li>
</ol>
<p>KafkaProducer 被配置为自动重试，如果多次重试后仍无法解决问题，则会抛出重试异常。另一类错误是无法通过重试来解决的，比如<code>消息过大</code>对于这类错误，KafkaProducer 不会进行重试，直接抛出异常。</p>
<h2 id="异步发送消息"><a href="#异步发送消息" class="headerlink" title="异步发送消息"></a>异步发送消息</h2><blockquote>
<p>同步的弊端不用我多说了吧，发送完必须等待消息返回后才进行下一个消息的发送，效率低下，但是如果你并不关心消息返回值，那用异步发送再合适不过了。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">ProducerRecord&lt;String, String&gt; producerRecord = <span class="keyword">new</span> <span class="title class_">ProducerRecord</span>&lt;String, String&gt;(<span class="string">&quot;CustomerCountry&quot;</span>, <span class="string">&quot;Huston&quot;</span>, <span class="string">&quot;America&quot;</span>);</span><br><span class="line">        producer.send(producerRecord,<span class="keyword">new</span> <span class="title class_">DemoProducerCallBack</span>());</span><br><span class="line"></span><br><span class="line"><span class="comment">//异步回调</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DemoProducerCallBack</span> <span class="keyword">implements</span> <span class="title class_">Callback</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onCompletion</span><span class="params">(RecordMetadata metadata, Exception exception)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(exception != <span class="literal">null</span>)&#123;</span><br><span class="line">      exception.printStackTrace();;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>异步调用的话会有消息回调，如果消息返回了错误，需要手动对错误进行处理。</p>
<h1 id="分区机制"><a href="#分区机制" class="headerlink" title="分区机制"></a>分区机制</h1><blockquote>
<p>partition代表分区，分区就是topic的分区。即topic会分成若干个区，然后该topic的会使用分区的策略来存储消息。</p>
<p>由于消息是存在主题（topic）的分区（partition）中的，所以当 Producer 生产者发送产生一条消息发给 topic 的时候，你如何判断这条消息会存在哪个分区中呢？</p>
</blockquote>
<h2 id="分区策略"><a href="#分区策略" class="headerlink" title="分区策略"></a>分区策略</h2><p>分区策略是可以自定义的，详细请参考Kafka官方文档。下面主要介绍几个默认的分区策略。</p>
<p><img src="/imgs/MQ-kafka/image-20220427001419885.png" alt="image-20220427001419885"></p>
<p>上图是分区的集群架构，一般来说，Broker集群中每一个broker都有相同的分区，如broker1中有topicA-p0，topicA-p1，topicB-p0，topicB-p1。而这一套分区在Broker2中也有，虎屋</p>
<h3 id="顺序轮询"><a href="#顺序轮询" class="headerlink" title="顺序轮询"></a><strong>顺序轮询</strong></h3><p>顺序分配，消息是均匀的分配给每个 partition，即每个分区存储一次消息。就像下面这样</p>
<img src="/imgs/MQ-kafka/16eb068cdf11869etplv-t2oaga2asx-zoom-in-crop-mark1304000.webp" alt="img" style="zoom: 50%;" />



<p>顺序轮训策略是 Kafka Producer 提供的默认策略。</p>
<h3 id="按照-key-进行消息保存"><a href="#按照-key-进行消息保存" class="headerlink" title="按照 key 进行消息保存"></a><strong>按照 key 进行消息保存</strong></h3><p>这个策略也叫做 <strong>key-ordering</strong> 策略，Kafka 中每条消息都会有自己的key，一旦消息被定义了 Key，那么你就可以保证同一个 Key 的所有消息都进入到相同的分区里面，由于每个分区下的消息处理都是有顺序的，故这个策略被称为按消息键保序策略，如下图所示</p>
<img src="/imgs/MQ-kafka/16eb068cdc3ca978tplv-t2oaga2asx-zoom-in-crop-mark1304000.webp" alt="img" style="zoom:50%;" />

<hr>
<p>闲谈一下，最近工作强度一下子上来了，导致每天都挺累的，不知道是不是工作太认真了😄</p>
<h1 id="重平衡"><a href="#重平衡" class="headerlink" title="重平衡"></a>重平衡</h1><p>当有消费者群组申请加入或者退出的时候，会触发重平衡。</p>
<p>重平衡会将分区均匀分摊给各个消费者（Rebalance），这是Kafka高可用和高伸缩的基础，可以在运行的过程中移除或添加消费者。</p>
<p>但是在重平衡期间，会发生Stop the world（详细参照JVM Full GC），即消费者无法读取到消息，整个消费者会处于不可用的状态。</p>
<h4 id="详细流程"><a href="#详细流程" class="headerlink" title="详细流程"></a>详细流程</h4><p>在消费者端，重平衡分为两个步骤：分别是加入组和等待领导者消费者（Leader Consumer）分配方案。这两个步骤分别对应两类特定的请求：<strong>JoinGroup</strong> 请求和 <strong>SyncGroup</strong> 请求。</p>
<ol>
<li>当组内成员加入组时，它会向协调者发送 <code>JoinGroup</code> 请求。在该请求中，每个成员都要将自己订阅的主题上报，这样协调者就能收集到所有成员的订阅信息。一旦收集了<code>全部</code>成员的 <code>JoinGroup</code> 请求后，协调者会从这些成员中选择一个担任这个消费者组的领导者。<strong>领导者消费者的任务是收集所有成员的订阅信息，然后根据这些信息，制定具体的分区消费分配方案。</strong></li>
<li>选出领导者之后，协调者会把消费者组订阅信息封装进 <code>JoinGroup</code> 请求的响应体中，然后发给领导者，由领导者统一做出分配方案后,领导者向协调者发送 <code>SyncGroup</code> 请求，将刚刚做出的分配方案发给协调者。</li>
<li>其他成员也会向协调者发送 <code>SyncGroup</code> 请求，只不过请求体中并没有实际的内容。这一步的主要目的是让协调者接收分配方案，然后统一以 <code>SyncGroup</code> 响应的方式分发给所有成员，这样组内所有成员就都知道自己该消费哪些分区了。</li>
</ol>
<p>如下图所示</p>
<img src="/imgs/MQ-kafka/16eb06909972f3f2tplv-t2oaga2asx-zoom-in-crop-mark1304000.webp" alt="img" style="zoom:50%;" />



<h4 id="场景一：新成员加入"><a href="#场景一：新成员加入" class="headerlink" title="场景一：新成员加入"></a>场景一：新成员加入</h4><p>当协调者收到新的 <code>JoinGroup</code> 请求后，它会通过心跳请求响应的方式通知组内现有的所有成员，强制它们开启新一轮的重平衡。具体的过程和之前的客户端重平衡流程是一样的。</p>
<p><img src="/imgs/MQ-kafka/c3bce7e305da4b32b1d938756ccc946etplv-k3u1fbpfcp-zoom-in-crop-mark1304000.webp" alt="image.png"></p>
<h4 id="场景二：成员主动离组"><a href="#场景二：成员主动离组" class="headerlink" title="场景二：成员主动离组"></a>场景二：成员主动离组</h4><p>消费者实例所在线程或进程调用 <code>close()</code> 方法主动通知协调者它要退出。这个场景就涉及到了第三类请求：<strong>LeaveGroup 请求</strong>。协调者收到 LeaveGroup 请求后，依然会以心跳响应的方式通知其他成员</p>
<p><img src="/imgs/MQ-kafka/c96a5cf54282445999c24c10c8c630betplv-k3u1fbpfcp-zoom-in-crop-mark1304000.webp" alt="image.png"></p>
<h4 id="场景三：组成员崩溃离组"><a href="#场景三：组成员崩溃离组" class="headerlink" title="场景三：组成员崩溃离组"></a>场景三：组成员崩溃离组</h4><p>他和成员主动离组的区别是它属于被动离开，broker端不知道成员离组，经过心跳超时后，判定成员离组的一种情况。</p>
<p><img src="/imgs/MQ-kafka/226f951500e2487c9bb9375c22176fdftplv-k3u1fbpfcp-zoom-in-crop-mark1304000.webp" alt="image.png"></p>
<p>流程摘自<a target="_blank" rel="noopener" href="https://juejin.cn/post/6992195021910835230">https://juejin.cn/post/6992195021910835230</a></p>
<h4 id="重平衡的三种默认策略"><a href="#重平衡的三种默认策略" class="headerlink" title="重平衡的三种默认策略"></a>重平衡的三种默认策略</h4><p><strong>range策略</strong>主要是基于范围的思想。</p>
<p>它将单个topic的所有分区按照顺序排列，然后把这些分区划分成固定大小的分区段并依次分配给每个consumer。</p>
<p><strong>round-robin策略</strong>则会把所有topic的所有分区顺序摆开，然后轮询式地分配给各个consumer。</p>
<p><strong>sticky策略</strong>有效地避免了上述两种策略完全无视历史分配方案的缺陷，采用了“有黏性”的策略对所有consumer实例进行分配，可以规避极端情况下的数据倾斜并且在两次rebalance间最大限度地维持了之前的分配方案。</p>
<p>通常意义上认为，如果group下所有consumer实例的订阅是相同的，那么使用round-robin会带来更公平的分配方案，否则使用range策略的效果更好。</p>
<p>关于策略详细可以参考这篇文章：<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/86718818">https://zhuanlan.zhihu.com/p/86718818</a></p>
<p>讲的是真滴详细👍</p>
<hr>
<p>2022.05.09更新</p>
<h1 id="订阅-发布模式实现"><a href="#订阅-发布模式实现" class="headerlink" title="订阅-发布模式实现"></a>订阅-发布模式实现</h1><p>Kafka是基于<strong>订阅-发布模式</strong>，生产者发送消息给Broker，那消费者是如何知道生产者发送了数据呢？</p>
<p>此处实现订阅-发布者模式，需要消费者定期轮询Kafka Broker，对订阅的topic分区中检索消息，如果有就用来消费，没有就继续轮询下去。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    ConsumerRecords&lt;String, String&gt; records = consumer.poll(Duration.ofSeconds(<span class="number">100</span>));</span><br><span class="line">    <span class="keyword">for</span> (ConsumerRecord&lt;String, String&gt; record : records) &#123;</span><br><span class="line">      <span class="type">int</span> <span class="variable">updateCount</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">      <span class="keyword">if</span> (map.containsKey(record.value())) &#123;</span><br><span class="line">        updateCount = (<span class="type">int</span>) map.get(record.value() + <span class="number">1</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      map.put(record.value(), updateCount);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">  consumer.close();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h1 id="提交和偏移量概念"><a href="#提交和偏移量概念" class="headerlink" title="提交和偏移量概念"></a>提交和偏移量概念</h1><p>有一个特殊的主题**_consumer_offset**，此主题会保存每次发送消息中分区的偏移量，这个主题主要是防止消息丢失。</p>
<p>当重平衡后，消费者会被重新分配分区，_consumer_offset中记录下重平衡前的最后一次提交的偏移量。</p>
<p>重平衡后，会以上次提交的偏移量位置为起点，进行消费。如图所示，即使当前处理消息为8，但是最后一次提交的偏移量为2，所以重平衡后还是会从2开始消费。</p>
<p>注意，这样可能会导致重复消费，但是同时保证了消息不丢失，只需要做好幂等处理即可。</p>
<img src="/imgs/MQ-kafka/16eb0690b6721d0dtplv-t2oaga2asx-zoom-in-crop-mark1304000.webp" alt="img" style="zoom: 50%;" />





<p>如果<strong>提交的偏移量大于最后一次消费时的偏移量</strong>，那么处于两个偏移量中间的消息将会丢失</p>
<img src="/imgs/MQ-kafka/16eb0691023e677etplv-t2oaga2asx-zoom-in-crop-mark1304000.webp" alt="img" style="zoom:50%;" />



<h2 id="自动提交"><a href="#自动提交" class="headerlink" title="自动提交"></a>自动提交</h2><p>如果enable.auto.commit设置为了true，那么默认每过5s，消费者端会自动将轮询拉取下来的消息最大的偏移量提交上去。</p>
<p>自动提交存在的问题：</p>
<ul>
<li>如果消费并处理完毕，但是还没来得及提交offset，消费者宕机，当消费者重新拉起，就会从上一次提交的offset处进行消费，就会重复消费了。</li>
<li>如果提交了当前最新offset，而消息又没有处理完成，此时消费者又宕机了。但是重新拉起消费者以后，会从最新的offset开始消费，导致宕机前没处理完成的消息丢失。</li>
</ul>
<h2 id="手动提交"><a href="#手动提交" class="headerlink" title="手动提交"></a>手动提交</h2><p>手动提交即为处理完成后回调提交，同时手动提交也分为异步提交和同步提交。也可以异步+同步组合的方式提交。</p>
<p><strong>同步提交</strong></p>
<p>手动提交失败后会一直重试，直到重试成功，或者遇到无法重试的情况才结束，这样虽说能够最大限度的保证消息不丢失，但是同时在重试的过程中也阻塞了线程，限制了吞吐量。</p>
<p>手动同步提交应用在对消息丢失容忍度较低的情况下，以此最大限度的额保证消息不丢失。</p>
<p><strong>异步提交</strong></p>
<p>异步提交不会阻塞线程，但同时也不会进行重试，可以配合回调函数在提交失败的时候记录错误信息。</p>
<p><strong>组合提交</strong></p>
<p>对于常规性、阶段性的手动提交，我们调用 commitAsync() 避免程序阻塞，而在 Consumer 要关闭前，我们调用 commitSync() 方法执行同步阻塞式的位移提交，以确保 Consumer 关闭前能够保存正确的位移数据。将两者结合后，我们既实现了异步无阻塞式的位移管理，也确保了 Consumer 位移的正确性。</p>
<h1 id="Kafka-ACK-机制"><a href="#Kafka-ACK-机制" class="headerlink" title="Kafka ACK 机制"></a>Kafka ACK 机制</h1><p>当生产者发送给Broker消息时，会有一个ack机制，ack有三种级别。默认为ack = 1。</p>
<p><strong>acks = 0表示producer不需要等待任何broker确认收到消息的回复，就可以继续发送下一条消息。</strong>性能最高，但是最容易丢消息。对数据丢失不敏感的情况可以用这种。</p>
<p><strong>acks = 1至少要等待leader已经成功将数据写入本地log，但是不需要等待所有follower是否成功写入。</strong>就可以继续发送下一条消息。这种情况下，如果follower没有成功备份数据，而此时leader又挂掉，则消息会丢失。</p>
<p><strong>acks = -1或all这意味着leader需要等待所有备份(配合min.insync.replicas（最少同步副本数）使用)都成功写入日志，</strong>这种策略会保证只要有一个备份存活就不会丢失数据。这是最强的数据保证。一般除非是金融级别，或跟钱打交道的场景才会使用这种配置。当然如果min.insync.replicas配置的是1则也可能丢消息，跟acks=1情况类似。</p>
<p>retries，客户端发送失败，重试次数（默认：2147483647，即Integer.MAX_VALUE）。如果设置为0，只要发送消息失败，这笔消息就丢失了</p>
<h1 id="Kafka应用与生产上的一些问题"><a href="#Kafka应用与生产上的一些问题" class="headerlink" title="Kafka应用与生产上的一些问题"></a>Kafka应用与生产上的一些问题</h1><h2 id="重复消费"><a href="#重复消费" class="headerlink" title="重复消费"></a>重复消费</h2><p>重复消费是非常常见的生产问题，一般发生在消息处理过后但没来得及向broker提交最新的offset，消费者就宕机了。此时提交给broker的offset还是上一次的</p>
<p>在重新启动该消费者以后，会从上一次提交处开始消费。</p>
<p><strong>解决方案</strong></p>
<p>1、一些超时后会出发Rebalance的参数可以设置更加合理（大一点），防止因超时而出发重试。</p>
<p>2、去重表。在消费端的Redis或者MySql保存【当前从broker拉取消息批次的ID】，查询是否已经处理过，处理过则跳过。</p>
<p>3、做幂等处理。</p>
<h2 id="消息丢失"><a href="#消息丢失" class="headerlink" title="消息丢失"></a>消息丢失</h2><p>消息丢失，会发生在生产者端、Broker端、消费者端。</p>
<p><strong>生产者端丢失</strong></p>
<p>当ack =0，即不需要等待broker回复确认收到的消息，就可以继续发送下一条。这种情况易造成消息丢失，如broker宕机，消费者这边还在持续发送消息。</p>
<p>当ack = 1，即至少等待leader节点写入到本地后，才返回消息给生产者端。</p>
<p>但是存在一种情况，leader将消息写入本地，返回确认收到给生产者端后，在没有来得及同步给follower，宕机，这种情况会造成消息丢失。</p>
<p><strong>Broker端丢失</strong></p>
<p>unclean.leader.election.enable 配置true broker端配置<br>允许选举ISR以外的副本作为leader,会导致数据丢失，默认为false。producer发送异步消息完，只等待lead写入成功就返回了，leader crash了，这时ISR中没有follower，leader从OSR中选举，因为OSR中本来落后于Leader造成消息丢失。</p>
<h1 id="关于Kafka集群"><a href="#关于Kafka集群" class="headerlink" title="关于Kafka集群"></a>关于Kafka集群</h1><blockquote>
<p>系统的高可用、高吞吐必然离不开集群，kafka也是一样的，下面讲述Kafka集群的结构设计。</p>
</blockquote>
<p>现在有一个topicA，分成了2个分区，放在三台服务器上。我们知道，主要进行消息读写的是leader分区，所以我们尽量要保证leader均匀分布在各个broker上，这样就算broker宕机后，也不会对Kafka集群的可用性造成很大的冲击。</p>
<p>比如，我们有3个Broker，2个分区分别有2个备份（一共是3组相同的分区），每个分区的leader在一个broker只能有一个，这样保证了集群的高可用。</p>
<p>同时topicB、topicC都遵循这样的原则，这就是集群的意义所在，让服务更加的高可用，提高系统容错性，同时就是需要占用不小的资源。</p>
<p><img src="/imgs/MQ-kafka/image-20220427233325900.png" alt="image-20220427233325900"></p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:378435665@qq.com">Louis</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://intlouis.github.io/2022/04/23/MQ-kafka/">https://intlouis.github.io/2022/04/23/MQ-kafka/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://intlouis.github.io" target="_blank">Welcome!</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97-Kafka/">-消息队列 -Kafka</a></div><div class="post_share"><div class="social-share" data-image="/imgs/007ZVs3Jgy1h0qz8hqf8cj30go0go75i.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2022/05/15/MySQL%EF%BC%881%EF%BC%89%E2%80%94%E2%80%94%E5%9B%9B%E5%A4%A7%E7%89%B9%E6%80%A7%E4%BB%A5%E5%8F%8A%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB%E7%9A%84%E5%AE%9E%E7%8E%B0/"><img class="prev-cover" src="/imgs/007ZVs3Jgy1h0qz8hqf8cj30go0go75i.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">MySQL（1）——四大特性以及隔离级别的实现</div></div></a></div><div class="next-post pull-right"><a href="/2022/04/07/SpringCloud%E2%80%94%E2%80%94%E9%99%90%E6%B5%81%E3%80%81%E7%86%94%E6%96%AD%E4%B9%8BSentinel/"><img class="next-cover" src="/imgs/007ZVs3Jgy1h0qz8hqf8cj30go0go75i.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">微服务浅谈（四）——限流、熔断之Sentinel</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/img.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">Louis</div><div class="author-info__description">就职于不知名小公司，无事来此放放屁</div></div><div class="card-info-data is-center"><div class="card-info-data-item"><a href="/archives/"><div class="headline">文章</div><div class="length-num">10</div></a></div><div class="card-info-data-item"><a href="/tags/"><div class="headline">标签</div><div class="length-num">15</div></a></div><div class="card-info-data-item"><a href="/categories/"><div class="headline">分类</div><div class="length-num">2</div></a></div></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/intLouis"><i class="fab fa-github"></i><span>博主的Github</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/intLouis" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="mailto:378435665@qq.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">I hava a DREAM</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content is-expand"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E6%9C%AF%E8%AF%AD"><span class="toc-number">1.</span> <span class="toc-text">基本术语</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Kafka%E7%89%B9%E6%80%A7"><span class="toc-number">2.</span> <span class="toc-text">Kafka特性</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Kafka-%E7%9A%84%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E6%A8%A1%E5%BC%8F"><span class="toc-number">3.</span> <span class="toc-text">Kafka 的消息队列模式</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%9B%9B%E4%B8%AA%E6%A0%B8%E5%BF%83API"><span class="toc-number">4.</span> <span class="toc-text">四个核心API</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Kafka-%E4%B8%BA%E4%BD%95%E5%A6%82%E6%AD%A4%E4%B9%8B%E5%BF%AB"><span class="toc-number">5.</span> <span class="toc-text">Kafka 为何如此之快</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9B%B6%E6%8B%B7%E8%B4%9D"><span class="toc-number">5.1.</span> <span class="toc-text">零拷贝</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%89%8D%E6%99%AF%E6%8F%90%E8%A6%81%EF%BC%9ADMA%EF%BC%88Direct-Memory-Access%EF%BC%89"><span class="toc-number">5.2.</span> <span class="toc-text">前景提要：DMA（Direct Memory Access）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#mmap"><span class="toc-number">5.3.</span> <span class="toc-text">mmap</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#sendfile"><span class="toc-number">5.4.</span> <span class="toc-text">sendfile</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Kafka%E6%B6%88%E6%81%AF%E5%8F%91%E9%80%81"><span class="toc-number">6.</span> <span class="toc-text">Kafka消息发送</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AE%80%E5%8D%95%E6%B6%88%E6%81%AF%E5%8F%91%E9%80%81"><span class="toc-number">6.1.</span> <span class="toc-text">简单消息发送</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%90%8C%E6%AD%A5%E5%8F%91%E9%80%81%E6%B6%88%E6%81%AF"><span class="toc-number">6.2.</span> <span class="toc-text">同步发送消息</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BC%82%E6%AD%A5%E5%8F%91%E9%80%81%E6%B6%88%E6%81%AF"><span class="toc-number">6.3.</span> <span class="toc-text">异步发送消息</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%88%86%E5%8C%BA%E6%9C%BA%E5%88%B6"><span class="toc-number">7.</span> <span class="toc-text">分区机制</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%86%E5%8C%BA%E7%AD%96%E7%95%A5"><span class="toc-number">7.1.</span> <span class="toc-text">分区策略</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A1%BA%E5%BA%8F%E8%BD%AE%E8%AF%A2"><span class="toc-number">7.1.1.</span> <span class="toc-text">顺序轮询</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8C%89%E7%85%A7-key-%E8%BF%9B%E8%A1%8C%E6%B6%88%E6%81%AF%E4%BF%9D%E5%AD%98"><span class="toc-number">7.1.2.</span> <span class="toc-text">按照 key 进行消息保存</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%87%8D%E5%B9%B3%E8%A1%A1"><span class="toc-number">8.</span> <span class="toc-text">重平衡</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AF%A6%E7%BB%86%E6%B5%81%E7%A8%8B"><span class="toc-number">8.0.0.1.</span> <span class="toc-text">详细流程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9C%BA%E6%99%AF%E4%B8%80%EF%BC%9A%E6%96%B0%E6%88%90%E5%91%98%E5%8A%A0%E5%85%A5"><span class="toc-number">8.0.0.2.</span> <span class="toc-text">场景一：新成员加入</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9C%BA%E6%99%AF%E4%BA%8C%EF%BC%9A%E6%88%90%E5%91%98%E4%B8%BB%E5%8A%A8%E7%A6%BB%E7%BB%84"><span class="toc-number">8.0.0.3.</span> <span class="toc-text">场景二：成员主动离组</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9C%BA%E6%99%AF%E4%B8%89%EF%BC%9A%E7%BB%84%E6%88%90%E5%91%98%E5%B4%A9%E6%BA%83%E7%A6%BB%E7%BB%84"><span class="toc-number">8.0.0.4.</span> <span class="toc-text">场景三：组成员崩溃离组</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%87%8D%E5%B9%B3%E8%A1%A1%E7%9A%84%E4%B8%89%E7%A7%8D%E9%BB%98%E8%AE%A4%E7%AD%96%E7%95%A5"><span class="toc-number">8.0.0.5.</span> <span class="toc-text">重平衡的三种默认策略</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%AE%A2%E9%98%85-%E5%8F%91%E5%B8%83%E6%A8%A1%E5%BC%8F%E5%AE%9E%E7%8E%B0"><span class="toc-number">9.</span> <span class="toc-text">订阅-发布模式实现</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%8F%90%E4%BA%A4%E5%92%8C%E5%81%8F%E7%A7%BB%E9%87%8F%E6%A6%82%E5%BF%B5"><span class="toc-number">10.</span> <span class="toc-text">提交和偏移量概念</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%87%AA%E5%8A%A8%E6%8F%90%E4%BA%A4"><span class="toc-number">10.1.</span> <span class="toc-text">自动提交</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%89%8B%E5%8A%A8%E6%8F%90%E4%BA%A4"><span class="toc-number">10.2.</span> <span class="toc-text">手动提交</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Kafka-ACK-%E6%9C%BA%E5%88%B6"><span class="toc-number">11.</span> <span class="toc-text">Kafka ACK 机制</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Kafka%E5%BA%94%E7%94%A8%E4%B8%8E%E7%94%9F%E4%BA%A7%E4%B8%8A%E7%9A%84%E4%B8%80%E4%BA%9B%E9%97%AE%E9%A2%98"><span class="toc-number">12.</span> <span class="toc-text">Kafka应用与生产上的一些问题</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%87%8D%E5%A4%8D%E6%B6%88%E8%B4%B9"><span class="toc-number">12.1.</span> <span class="toc-text">重复消费</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B6%88%E6%81%AF%E4%B8%A2%E5%A4%B1"><span class="toc-number">12.2.</span> <span class="toc-text">消息丢失</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%85%B3%E4%BA%8EKafka%E9%9B%86%E7%BE%A4"><span class="toc-number">13.</span> <span class="toc-text">关于Kafka集群</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2022/07/12/%E8%BF%99%E4%B8%80%E4%B8%AA%E6%9C%88%E9%9D%A2%E8%AF%95%E7%9A%84%E6%80%BB%E7%BB%93/" title="这一个月面试的总结"><img src="/imgs/007ZVs3Jgy1h0qz8hqf8cj30go0go75i.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="这一个月面试的总结"/></a><div class="content"><a class="title" href="/2022/07/12/%E8%BF%99%E4%B8%80%E4%B8%AA%E6%9C%88%E9%9D%A2%E8%AF%95%E7%9A%84%E6%80%BB%E7%BB%93/" title="这一个月面试的总结">这一个月面试的总结</a><time datetime="2022-07-11T16:37:31.000Z" title="发表于 2022-07-12 00:37:31">2022-07-12</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/06/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%EF%BC%88%E4%B8%80%EF%BC%89%E2%80%94%E2%80%94%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB/" title="计算机网络（一）——基础知识体系"><img src="/imgs/007ZVs3Jgy1h0qz8hqf8cj30go0go75i.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="计算机网络（一）——基础知识体系"/></a><div class="content"><a class="title" href="/2022/06/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%EF%BC%88%E4%B8%80%EF%BC%89%E2%80%94%E2%80%94%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB/" title="计算机网络（一）——基础知识体系">计算机网络（一）——基础知识体系</a><time datetime="2022-06-25T17:17:29.000Z" title="发表于 2022-06-26 01:17:29">2022-06-26</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/06/18/%E6%95%B0%E6%8D%AE%E4%B8%80%E8%87%B4%E6%80%A7%E4%B9%8B%E7%BC%93%E5%AD%98%E4%B8%80%E8%87%B4%E6%80%A7/" title="数据一致性之缓存一致性"><img src="/imgs/007ZVs3Jgy1h0qz8hqf8cj30go0go75i.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="数据一致性之缓存一致性"/></a><div class="content"><a class="title" href="/2022/06/18/%E6%95%B0%E6%8D%AE%E4%B8%80%E8%87%B4%E6%80%A7%E4%B9%8B%E7%BC%93%E5%AD%98%E4%B8%80%E8%87%B4%E6%80%A7/" title="数据一致性之缓存一致性">数据一致性之缓存一致性</a><time datetime="2022-06-17T18:26:41.000Z" title="发表于 2022-06-18 02:26:41">2022-06-18</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/05/19/Redis%E4%BD%A0%E4%BA%86%E8%A7%A3%E5%A4%9A%E5%B0%91%EF%BC%9F%E8%AE%B2%E8%AE%B2%EF%BC%9F/" title="Redis基础浅谈（一）"><img src="/imgs/007ZVs3Jgy1h0qz8hqf8cj30go0go75i.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Redis基础浅谈（一）"/></a><div class="content"><a class="title" href="/2022/05/19/Redis%E4%BD%A0%E4%BA%86%E8%A7%A3%E5%A4%9A%E5%B0%91%EF%BC%9F%E8%AE%B2%E8%AE%B2%EF%BC%9F/" title="Redis基础浅谈（一）">Redis基础浅谈（一）</a><time datetime="2022-05-19T15:57:22.000Z" title="发表于 2022-05-19 23:57:22">2022-05-19</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/05/15/MySQL%EF%BC%881%EF%BC%89%E2%80%94%E2%80%94%E5%9B%9B%E5%A4%A7%E7%89%B9%E6%80%A7%E4%BB%A5%E5%8F%8A%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB%E7%9A%84%E5%AE%9E%E7%8E%B0/" title="MySQL（1）——四大特性以及隔离级别的实现"><img src="/imgs/007ZVs3Jgy1h0qz8hqf8cj30go0go75i.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="MySQL（1）——四大特性以及隔离级别的实现"/></a><div class="content"><a class="title" href="/2022/05/15/MySQL%EF%BC%881%EF%BC%89%E2%80%94%E2%80%94%E5%9B%9B%E5%A4%A7%E7%89%B9%E6%80%A7%E4%BB%A5%E5%8F%8A%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB%E7%9A%84%E5%AE%9E%E7%8E%B0/" title="MySQL（1）——四大特性以及隔离级别的实现">MySQL（1）——四大特性以及隔离级别的实现</a><time datetime="2022-05-15T05:11:16.000Z" title="发表于 2022-05-15 13:11:16">2022-05-15</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url('/imgs/007ZVs3Jgy1h0cpba32yzj30zk0zkk0i.jpg')"><div id="footer-wrap"><div class="copyright">&copy;2022 By Louis</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="footer_custom_text">You Hava a DREAM ?</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.js"></script><script>var preloader = {
  endLoading: () => {
    document.body.style.overflow = 'auto';
    document.getElementById('loading-box').classList.add("loaded")
  },
  initLoading: () => {
    document.body.style.overflow = '';
    document.getElementById('loading-box').classList.remove("loaded")

  }
}
window.addEventListener('load',preloader.endLoading())</script><div class="js-pjax"></div><script defer="defer" id="ribbon" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/canvas-ribbon.min.js" size="150" alpha="0.6" zIndex="-1" mobile="false" data-click="true"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>