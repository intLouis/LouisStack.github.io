{"meta":{"title":"Welcome!","subtitle":"嘿嘿","description":"就职于不知名小公司，无事来此放放屁","author":"Louis","url":"https://intlouis.github.io","root":"/"},"pages":[{"title":"关于我","date":"2022-03-25T17:45:27.000Z","updated":"2022-03-27T07:39:36.790Z","comments":true,"path":"about/index.html","permalink":"https://intlouis.github.io/about/index.html","excerpt":"","text":"菜鸟一个而已"},{"title":"标签😄","date":"2022-03-25T17:39:45.000Z","updated":"2022-03-26T08:02:29.473Z","comments":true,"path":"tags/index.html","permalink":"https://intlouis.github.io/tags/index.html","excerpt":"","text":""},{"title":"分类","date":"2022-03-25T17:40:40.000Z","updated":"2022-03-26T08:01:58.961Z","comments":true,"path":"categories/index.html","permalink":"https://intlouis.github.io/categories/index.html","excerpt":"","text":""},{"title":"友链","date":"2022-03-18T01:49:42.000Z","updated":"2022-03-18T01:50:45.199Z","comments":true,"path":"link/index.html","permalink":"https://intlouis.github.io/link/index.html","excerpt":"","text":""}],"posts":[{"title":"微服务浅谈（三）——Gateway网关","slug":"SpringCloud-网关","date":"2022-03-27T16:39:32.000Z","updated":"2022-03-29T15:02:58.252Z","comments":true,"path":"2022/03/28/SpringCloud-网关/","link":"","permalink":"https://intlouis.github.io/2022/03/28/SpringCloud-%E7%BD%91%E5%85%B3/","excerpt":"","text":"所有请求必经之门——网关Nginx与Gateway的区别SpringCloud Gateway作为网关，其作用和Nginx是有区别的。 1、Gateway和Nginx可以取其一进行使用，也可以两个都使用，具体是看系统结构和业务需求，这个很重要。 2、Gateway更加贴近业务层面，因为它可以在截到请求后执行一些鉴权、过滤、断言等，做一些基本的流控。 3、Nginx更多是作为流量的总入口，负载均衡等。 4、Nginx支持Lua脚本，但是其始终是需要进行二次开发，扩展性不如Gateway。 SpringCloud Gateway 更加靠近业务。 假设系统结构是： Ng-&gt;Gateway-&gt;业务层，那么Ng只是作为一个流量入口的作用，并没有接触到业务。而Gateway可以将请求路由到服务端（某一微服务）。 Gateway 可以与Nacos集成，通过拉取Nacos中注册中心的地址，通过拉取到的地址进行转发，这样避免了将请求地址写死在配置中。同时，也会在转发请求的时候遵循你设置好的Ribbon负载均衡策略。 Gateway几个基本信息 id：路由标识符，区别于其他 Route。 uri：路由指向的目的地 uri，即客户端请求最终被转发到的微服务。 order：用于多个 Route 之间的排序，数值越小排序越靠前，匹配优先级越高。 predicate：断言的作用是进行条件判断，只有断言都返回真，才会真正的执行路由。 filter：过滤器用于修改请求和响应信息。 predicate：断言，用于进行条件判断，只有断言都返回真，才会真正的执行路由。 将这几个参数理解即可，会在配置文件中使用到。 过滤器过滤器的生命周期： 1、PRE：这种过滤器会在请求被路由前，即转发请求前会执行过滤器中编写的逻辑代码。我们一般会用这种过滤器进行身份验证、挑选服务实例、日志追踪、请求者信息记录等等。 2、POST：这种过滤器会在请求路由到服务后，执行相应逻辑代码。这种过滤器可用来为响应添加标准的HTTP Header、收集统计信息和指标、将响应从微服务发送给客户端等。 两种Filter：GatewayFilter与GlobalFilter，顾名思义，一个是局部过滤，一个是全局过滤。 局部过滤器局部过滤器提供的API的功能一般来说可以满足大部分的需求了： 过滤器工厂 作用 参数 AddRequestHeader 为原始请求添加Header Header的名称及值 AddRequestParameter 为原始请求添加请求参数 参数名称及值 AddResponseHeader 为原始响应添加Header Header的名称及值 DedupeResponseHeader 剔除响应头中重复的值 需要去重的Header名称及去重策略 Hystrix 为路由引入Hystrix的断路器保护 HystrixCommand 的名称 FallbackHeaders 为fallbackUri的请求头中添加具体的异常信息 Header的名称 PrefixPath 为原始请求路径添加前缀 前缀路径 PreserveHostHeader 为请求添加一个preserveHostHeader=true的属性，路由过滤器会检查该属性以决定是否要发送原始的Host 无 RequestRateLimiter 用于对请求限流，限流算法为令牌桶 keyResolver、 rateLimiter、 statusCode、 denyEmptyKey、 emptyKeyStatus RedirectTo 将原始请求重定向到指定的URL http状态码及重定向的url RemoveHopByHopHeadersFilter 为原始请求删除IETF组织规定的一系列Header 默认就会启用，可以通过配置指定仅删除哪些Header RemoveRequestHeader 为原始请求删除某个Header Header名称 RemoveResponseHeader 为原始响应删除某个Header Header名称 RewritePath 重写原始的请求路径 原始路径正则表达式以及重写后路径的正则表达式 RewriteResponseHeader 重写原始响应中的某个Header Header名称，值的正则表达式，重写后的值 SaveSession 在转发请求之前，强制执行WebSession::save操作 无 secureHeaders 为原始响应添加一系列起安全作用的响应头 无，支持修改这些安全响应头的值 SetPath 修改原始的请求路径 修改后的路径 SetResponseHeader 修改原始响应中某个Header的值 Header名称，修改后的值 SetStatus 修改原始响应的状态码 HTTP 状态码，可以是数字，也可以是字符串 StripPrefix 用于截断原始请求的路径 使用数字表示要截断的路径的数量 Retry 针对不同的响应进行重试 retries、statuses、methods、series RequestSize 设置允许接收最大请求包的大小。如果请求包大小超过设置的值，则返回 413 Payload Too Large 请求包大小，单位为字节，默认值为5M ModifyRequestBody 在转发请求之前修改原始请求体内容 修改后的请求体内容 ModifyResponseBody 修改原始响应体的内容 修改后的响应体内容 自定义局部过滤器 自定义局部过滤器很好理解，相信各位都写过拦截用户请求进行鉴权的拦截器，网关其实也是这么一个原理，只不过网关远远比我们自己写的拦截器功能更加丰富。 重点：名称是有固定格式【xxxGatewayFilterFactory】，这个很重要，关系到后面的配置类中的编写。 举例，我要打印每个接口的耗时： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051@Componentpublic class TimeGatewayFilterFactory extends AbstractGatewayFilterFactory&lt;TimeGatewayFilterFactory.Config&gt; &#123; private static final String BEGIN_TIME = &quot;beginTime&quot;; //构造函数 public TimeGatewayFilterFactory() &#123; super(TimeGatewayFilterFactory.Config.class); &#125; //读取配置文件中的参数 赋值到 配置类中 @Override public List&lt;String&gt; shortcutFieldOrder() &#123; return Arrays.asList(&quot;show&quot;); &#125; @Override public GatewayFilter apply(Config config) &#123; return new GatewayFilter() &#123; @Override public Mono&lt;Void&gt; filter(ServerWebExchange exchange, GatewayFilterChain chain) &#123; if (!config.show)&#123; // 如果配置类中的show为false，表示放行 return chain.filter(exchange); &#125; exchange.getAttributes().put(BEGIN_TIME, System.currentTimeMillis()); /** * pre的逻辑 * chain.filter().then(Mono.fromRunable(()-&gt;&#123; * post的逻辑 * &#125;)) */ return chain.filter(exchange).then(Mono.fromRunnable(()-&gt;&#123; Long startTime = exchange.getAttribute(BEGIN_TIME); if (startTime != null) &#123; System.out.println(exchange.getRequest().getURI() + &quot;请求耗时: &quot; + (System.currentTimeMillis() - startTime) + &quot;ms&quot;); &#125; &#125;)); &#125; &#125;; &#125; @Setter @Getter static class Config&#123; private boolean show; &#125;&#125; 配置文件如下，因为我们的逻辑类名是TimeGatewayFilterFactory 所以其配置key就是Time=true/false，本例子转载于掘金大佬博客 1234567891011121314151617181920212223242526272829server: port: 9000spring: application: name: api-gateway cloud: nacos: discovery: server-addr: 127.0.0.1:8848 gateway: discovery: locator: enabled: true # 让gateway可以发现nacos中的微服务 routes: - id: product_route # 路由的名字 uri: lb://product-service # lb指的是从nacos中按照名称获取微服务,并遵循负载均衡策略 predicates: - Path=/product-serv/** # 符合这个规定的才进行1转发 filters: - StripPrefix=1 # 将第一层去掉 - id: order_route uri: lb://order-service predicates: - Path=/order-serv/** filters: - StripPrefix=1 - Time=true 全局过滤全局过滤，只需集成GlobalFilter即可编写自定义逻辑代码，无需其余的配置。 123456789101112131415@Componentpublic class AuthGlobalFilter implements GlobalFilter &#123; @Override public Mono&lt;Void&gt; filter(ServerWebExchange exchange, GatewayFilterChain chain) &#123; String token = exchange.getRequest().getQueryParams().getFirst(&quot;token&quot;); if (StringUtils.isBlank(token)) &#123; System.out.println(&quot;鉴权失败&quot;); exchange.getResponse().setStatusCode(HttpStatus.UNAUTHORIZED); return exchange.getResponse().setComplete(); &#125; return chain.filter(exchange); &#125;&#125; 除此之外默认有几种全局过滤器。 网关集成Sentinel本部分会在后续的Sentinel文章中详细讲解。","categories":[{"name":"微服务","slug":"微服务","permalink":"https://intlouis.github.io/categories/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"}],"tags":[{"name":"微服务","slug":"微服务","permalink":"https://intlouis.github.io/tags/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"},{"name":"SpringCloud","slug":"SpringCloud","permalink":"https://intlouis.github.io/tags/SpringCloud/"},{"name":"gateway","slug":"gateway","permalink":"https://intlouis.github.io/tags/gateway/"}]},{"title":"微服务浅谈（二）——服务调用&OpenFeign","slug":"SpringCloud-OpenFeign","date":"2022-03-14T16:41:15.000Z","updated":"2022-03-27T16:41:01.182Z","comments":true,"path":"2022/03/15/SpringCloud-OpenFeign/","link":"","permalink":"https://intlouis.github.io/2022/03/15/SpringCloud-OpenFeign/","excerpt":"","text":"服务调用的两种常用方式：RPC&amp;HTTPHTTP就不过多介绍了，稍微讲一下RPC的架构。 RPC架构一个完整的RPC架构里面包含了四个核心的组件，分别是Client，Client Stub，Server以及Server Stub，这个Stub可以理解为存根。 客户端(Client)，服务的调用方。 客户端存根(Client Stub)，存放服务端的地址消息，再将客户端的请求参数打包成网络消息，然后通过网络远程发送给服务方。 服务端(Server)，真正的服务提供者。 服务端存根(Server Stub)，接收客户端发送过来的消息，将消息解包，并调用本地的方法。 纵观整个过程，实际上就是客户端发起调用，然后本次调用经过Client Stub封装，发送给Server，然后Server Stub会解析发送过来的内容，并且将数据进行返回。 RPC的目标就是要把2、3、4、7、8、9这些步骤都封装起来。 RPC调用是使用自定义的数据格式进行传输，是基于原生TCP进行通信，速度较快，效率较高。 HTTP则是一种较为通用的调用方式，在跨语言上存在优势，只要提供restful风格的接口，则可以进行请求。 关于RPC与Http的技术选型：如果需要使用RPC调用，则需要服务提供方与消费方都是使用RPC调用，即需要双方使用相同的技术，如都使用Dubbo调用。 而Http则无需关注语言的实现，只需请求数据遵循restful规范即可。 如何选择？ 既然两种方式都可以实现远程调用，我们该如何选择呢？ 速度来看，RPC要比http更快，虽然底层都是TCP，但是http协议的信息往往比较臃肿 难度来看，RPC实现较为复杂，http相对比较简单 灵活性来看，http更胜一筹，因为它不关心实现细节，跨平台、跨语言。 因此，两者都有不同的使用场景： 如果对效率要求更高，并且开发过程使用统一的技术栈，那么用RPC还是不错的。 如果需要更加灵活，跨语言、跨平台，显然http更合适 那么我们该怎么选择呢？ 微服务，更加强调的是独立、自治、灵活。而RPC方式的限制较多，因此微服务框架中，一般都会采用基于Http的Rest风格服务。 RestTemplate存在的问题其实Rest存在的问题，只需要三个字概况，不够优雅（四个字），当调用服务的url拼接较多的参数时，这样的url会变得非常难以维护，这样拼接的url在实际生产中并不少见。 OpenFeign简介OpenFeign是一种可以在微服务之间实现“无感知调用“的一个中间件。 即引入这种中间件以后，各个接口之间的调用就像在单机上部署一样，无需过多的关注调用的地址和端口，这就是所谓的”无感知调用“，或许这样描述并不是非常恰当，但达意即可。 SpringMVC的注解，如@RequestMapping等等。OpenFeign的@FeignClient可以解析SpringMVC的@RequestMapping注解下的接口，并通过动态代理的方式产生实现类，实现类中做负载均衡并调用其他服务。 OpenFeign沿用SpringMVC的注解，大大地降低了学习成本，作为一个组件它是一个好组件😀 OpenFeign的底层还是使用了Ribbon，Ribbon的介绍在博客相关文章有介绍过，所以OpenFeign是一个调用+客户端负载均衡的一个微服务组件。 OpenFeign把RestTemplete，Ribbon，Hystrix糅合在了一起，在使用时就可以更加方便，优雅地完成整个服务的暴露，调用等。避免做一些重复的复制粘贴接口URL，或者重复定义接口等。还是非常值得去学习的。 但Hystrix一般由Sentinel代替了，关于Sentinel的博客文章后续会发布。 OpenFeign的简单使用 1、在启动类上增加@EnableFeignClients注解（注：以下例子来自OpenFeign官方文档） 1234567891011121314@SpringBootApplication@EnableFeignClientspublic class WebApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(WebApplication.class, args); &#125; @FeignClient(&quot;name&quot;) static interface NameService &#123; @RequestMapping(&quot;/&quot;) public String getName(); &#125;&#125; 2、StoreClient就是供消费者调用的接口，每个接口上添加MVC相应注解以及接口请求地址。一般来说会专门创建一个这样的interface以供消费者调用。 1234567891011121314@FeignClient(&quot;stores&quot;)public interface StoreClient &#123; @RequestMapping(method = RequestMethod.GET, value = &quot;/stores&quot;) List&lt;Store&gt; getStores(); @RequestMapping(method = RequestMethod.GET, value = &quot;/stores&quot;) Page&lt;Store&gt; getStores(Pageable pageable); @RequestMapping(method = RequestMethod.POST, value = &quot;/stores/&#123;storeId&#125;&quot;, consumes = &quot;application/json&quot;) Store update(@PathVariable(&quot;storeId&quot;) Long storeId, Store store); @RequestMapping(method = RequestMethod.DELETE, value = &quot;/stores/&#123;storeId:\\\\d+&#125;&quot;) void delete(@PathVariable Long storeId);&#125; 3、在消费者的Controller层，注入StoreClient这个对象，使用这个对象直接进行方法调用即可。 Feign的自定义配置日志级别： NONE：不打印任何日志。 BASIC：只记录请求方法、URL、响应状态码和执行时间 HEADERS：记录基本信息，请求和响应标题 FULL： 记录请求和响应标题、正文和行数据 还有其他的Feign自定义配置，在此就不一一赘述。","categories":[{"name":"微服务","slug":"微服务","permalink":"https://intlouis.github.io/categories/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"}],"tags":[{"name":"OpenFeign","slug":"OpenFeign","permalink":"https://intlouis.github.io/tags/OpenFeign/"},{"name":"微服务","slug":"微服务","permalink":"https://intlouis.github.io/tags/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"},{"name":"SpringCloud","slug":"SpringCloud","permalink":"https://intlouis.github.io/tags/SpringCloud/"}]},{"title":"微服务浅谈（一）——Nacos","slug":"SpringCloud_Nacos","date":"2022-03-13T11:31:08.440Z","updated":"2022-03-25T18:12:30.809Z","comments":true,"path":"2022/03/13/SpringCloud_Nacos/","link":"","permalink":"https://intlouis.github.io/2022/03/13/SpringCloud_Nacos/","excerpt":"","text":"服务注册中心注册中心基本原理 在使用注册中心时，一共有三种角色：服务提供者（Service Provider）、服务消费者（Service Consumer）、注册中心（Registry）。 服务发现原理：服务发现机制就是通过一个中间件去记录服务提供者的ip地址，服务名以及心跳等数据（比如用mysql去存储这些信息），然后服务消费者会去这个中间平台去查询相关信息，然后再去访问对应的地址，这就是服务注册和服务发现。 Nacos 提供对服务的实时的健康检查，阻止向不健康的主机或服务实例发送请求。Nacos 支持传输层 (PING 或 TCP)和应用层 (如 HTTP、MySQL、用户自定义）的健康检查。 对于复杂的云环境和网络拓扑环境中（如 VPC、边缘网络等）服务的健康检查，Nacos 提供了 agent 上报模式和服务端主动检测2种健康检查模式。Nacos 还提供了统一的健康检查仪表盘，帮助您根据健康状态管理服务的可用性及流量。 服务提供者：向注册中心注册为一个服务实例，并且向外部暴露调用接口。 服务消费者：向注册中心订阅需要调用的服务，并缓存服务的实例列表再内存中。后续，Consumer 向对应服务的 Provider 发起调用时，从内存中的该服务的实例列表选择一个，进行远程调用。 注册中心：当注册的实例超过一定时间未心跳（nacos默认30s心跳一次，若下一次未收到，将不再路由请求至该实例），则注册中心判断这个服务已下线，将从服务实例列表移除。 不同的注册中心可能在实现原理上会略有差异。例如说，Eureka 注册中心，并不提供通知功能，而是 Eureka Client 自己定期轮询，实现本地缓存的更新。 当然，一个服务消费者，也可以是一个服务提供者。 nacos 作为注册中心时，Namespace + Group + Service 作为配置中心时，Namespace + Group + DataId 元数据： Nacos数据（如配置和服务）描述信息，如服务版本、权重、容灾策略、负载均衡策略、鉴权配置、各种自定义标签（label），从作用范围来看，分为服务级别的元信息、集群的元信息及实例的元信息。 Nacos1.x与Nacos2.xNacos1.x对比存在的问题 1、心跳续约是30s（默认），当服务较多时，就会有较高的TPS数。 2、心跳感知问题，心跳感知为15s无应答，即15秒未感知到应用心跳时，才能删除实例，在并发较高的情况下，降低服务的高可用。如：当服务宕机时，需要快速剔除服务实例，但需要等待15s，这样的时效性并不理想。 3、有HTTP和UDP两种数据推送的方式，与客户端需要进行全量对账（保持服务发现），会进行大量查询，导致QPS较高，这种可以理解成牺牲大量的查询来保持服务的发现，但实际生产中，所有的服务都是较为稳定的，大量的查询实际是为了那仅有的几个服务变动而设计，这样的性价比并不高。 Nacos2.x优化 1、使用长连接进行心跳续约，大大降低重复请求。同时长连接在断开时是可以快速感知到的，不需要等待15s。 2、连接反复创建存在开销，使用长连接减少了这样的开销，同时减少了TIME_WAIT的问题。 2.0架构带来的问题 相对于Tomcat HTTP短连接模型，长连接模型需要自己管理连接状态，增加了复杂性 长连接gRPC基于HTTP2.0 Stream，相对于HTTP的open API可观测性和易用性降低了 两者性能对比 具体性能分析可参照这篇博文：重磅官宣：Nacos2.0 发布，性能提升 10 倍 负载均衡服务器端负载均衡： 由中间件Ng进行路由 客户端负载均衡： 根据负载均衡规则，自行请求。 Ribbon：提供丰富的负载均衡算法。 手写一个客户端侧负载均衡器 手写负载均衡器部分代码如图： 这段代码的意思就是在实例列表中随机进行请求。这段代码只是粗略展示负载均衡的其中一个算法。 手写负载均衡器主要原理就是获取到此服务的所有url，然后以轮询、随机等方式进行调用指定的url Ribbon与Nginx的区别既然提到了负载均衡，怎么能少得了Nginx呢，Ribbon和Nginx之间的不同在于，Nginx是集中式的对接收的请求进行负载均衡，而Ribbon是在消费者端进行负载均衡，形象一点就是如下图。 NginxNginx的工作模型如下图： RibbonRibbon的工作模型如下图 Ribbon的负载均衡与Ng的负载均衡之不同就是，Ng是被动负载均衡，Ribbon是主动负载均衡。 Ribbon会在收到Http请求后，去拉取注册中心中的服务实例List，获取到List以后，会使用负载均衡策略，在List中挑选一个服务实例进行请求。 Ribbon默认是懒加载，懒加载会使项目启动速度加快，但是同时在第一次请求时，会去拉取注册中心的服务实例，以及初始化负载均衡容器，导致请求响应速度相对较慢。同时可选定服务进行配置饥饿加载。 同时Ribbon有多种负载均衡的策略模式可供选择，默认的就是同区域轮训模式：ZoneAwareLoadBalancer 是一个根据区域（Zone） 来进行负载均衡器，因为如果不同机房跨区域部署服务列表，跨区域的方式访问会产生更高的延迟，ZoneAwareLoadBalancer 就是为了解决此类问题，不过默认都是同一区域 Ribbon负载均衡策略： 策略类 命名 描述 RandomRule 随机策略 随机选择server RoundRobinRule 轮询策略 轮询选择， 轮询index，选择index对应位置的Server； RetryRule 重试策略 对选定的负载均衡策略机上重试机制，在一个配置时间段内当选择Server不成功，则一直尝试使用subRule的方式选择一个可用的server； BestAvailableRule 最低并发策略 逐个考察server，如果server断路器打开，则忽略，再选择其中并发链接最低的server AvailabilityFilteringRule 可用过滤策略 过滤掉一直失败并被标记为circuit tripped的server，过滤掉那些高并发链接的server（active connections超过配置的阈值）或者使用一个AvailabilityPredicate来包含过滤server的逻辑，其实就就是检查status里记录的各个Server的运行状态； ResponseTimeWeightedRule 响应时间加权重策略 根据server的响应时间分配权重，响应时间越长，权重越低，被选择到的概率也就越低。响应时间越短，权重越高，被选中的概率越高，这个策略很贴切，综合了各种因素，比如：网络，磁盘，io等，都直接影响响应时间 ZoneAvoidanceRule 区域权重策略 综合判断server所在区域的性能，和server的可用性，轮询选择server并且判断一个AWS Zone的运行性能是否可用，剔除不可用的Zone中的所有server","categories":[{"name":"微服务","slug":"微服务","permalink":"https://intlouis.github.io/categories/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"}],"tags":[{"name":"微服务","slug":"微服务","permalink":"https://intlouis.github.io/tags/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"},{"name":"SpringCloud","slug":"SpringCloud","permalink":"https://intlouis.github.io/tags/SpringCloud/"},{"name":"Nacos","slug":"Nacos","permalink":"https://intlouis.github.io/tags/Nacos/"}]}],"categories":[{"name":"微服务","slug":"微服务","permalink":"https://intlouis.github.io/categories/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"}],"tags":[{"name":"微服务","slug":"微服务","permalink":"https://intlouis.github.io/tags/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"},{"name":"SpringCloud","slug":"SpringCloud","permalink":"https://intlouis.github.io/tags/SpringCloud/"},{"name":"gateway","slug":"gateway","permalink":"https://intlouis.github.io/tags/gateway/"},{"name":"OpenFeign","slug":"OpenFeign","permalink":"https://intlouis.github.io/tags/OpenFeign/"},{"name":"Nacos","slug":"Nacos","permalink":"https://intlouis.github.io/tags/Nacos/"}]}